// @Copyright 2018 Kristjan Haule 
#include <iostream>
#include <blitz/array.h>
#include <pybind11/pybind11.h>
#include <pybind11/numpy.h>
#include <pybind11/stl.h>
#include "slinalg.h"
#include "legendre.h"
using namespace blitz;
namespace py = pybind11;

void K_binned_2_Legendre(Array<double,2>& Ker, int lmax, int M)
{// We assume that the function f_i is binned on equidistant mesh on M-points interval [-1,1],
 // so that
 //     f_0     = Int[ f(x), {x,-1,-1+2/M}]
 //     f_i     = Int[ f(x), {x,-1+2*i/M, -1+2*(i+1)/M}]
 //     f_{M-1} = Int[ f(x), {x, 1-2/M, 1}]
 // We further assume that function f(x) is very well represented by Legendre polynomials in the form
 //     f(x) = \sum_l c_l P_l(x)
 // Then we know that
 //     f_i = \sum_l c_l Int[ P_l(x), {x,-1+2*i/M, -1+2*(i+1)/M}]
 // which can be cast into the form
 //     f_i  = \sum_l Ker0(i,l) * c_l
 // with
 //     K0(i,l) = Int[ P_l(x), {x,-1+2*i/M, -1+2*(i+1)/M}] = 1/(x_{i+1}-x_i) \sum_n p_{l,n} (x_{i+1}^{n+1}-x_i^{n+1})/(n+1)
 // We can then obtain coefficients c_l by inversion of K0, i.e.,
 //     c_l = K0^{-1} f_i
 // Because Kernel is singular, we regularize it by Ridge regression. This amounts of minimizing the functional
 //     chi2 = |Ker0 * c - f|^2 + alpha * c*c
 //  where alpha is a small positive constant.
 // The minimization of the functional delivers minimum at
 //     K0^T * (f - K0 * c) = alpha * c
 // If we use singular value decomposion on K0, i.e., K0 = U * S * Vt, we can solve
 //     c = Vt^T  * S/(S^2+alpha) * U^T * f
 // This function returns the following Kernel
 //     Ker = Vt^+ * S/(S^2+alpha) * U^T
 // so that we can use it to obtain Legendre coefficients cl by:
 //     cl(l)  = \sum_i Ker(l,i) * fi(i)
 // where fi(i) is binned function, and cl(l) are Legendre coefficients of function f(x) = \sum_l cl(l) P_l(x)
 //
  Array<double,2> cPl(lmax+1,lmax+1);
  LegendreCoeff(cPl, lmax);
  //cout << "cPl = " << cPl << endl;

  Array<double,2> Ker0(M,lmax+1);
  Ker0 = 0;
  for (int i=0; i<M; i++){
    double xi  = -1 +     2*i/(M+0.0);
    double xip = -1 + 2*(i+1)/(M+0.0);
    double xi_n = xi;
    double xip_n = xip;
    Array<double,1> r(lmax+1);
    for (int n=0; n<=lmax; n++){
      r(n) = (xip_n - xi_n)/(n+1.);
      xi_n *= xi;
      xip_n *= xip;
    }
    r *= 1/(xip-xi);
    for (int l=0; l<=lmax; l++)
      for (int n=0; n<=l; n++)
	Ker0(i,l) += r(n)*cPl(l,n);
  }
  Array<double,2> U, Vt;
  Array<double,1> S;
  int Nl;
  SVD(U, S, Vt, Nl, Ker0);
  Nl = lmax+1;
  double alpha=1e-10;
  Array<double,2> SU(Nl,M);
  SU=0.;
  for (int l1=0; l1<Nl; l1++){
    double S_regularized = S(l1)/(S(l1)*S(l1)+alpha);
    for (int i=0; i<M; i++)
      SU(l1,i) = S_regularized*U(i,l1);
  }
  Ker.resize(Nl,M);
  Product(Ker, Vt, "T", SU, "N");
}

void K_binned_2_Legendre(Array<double,2>& Ker, int lmax, const Array<double,1>& X)
{// We assume that the function f_i is binned on equidistant mesh on M-points interval [-1,1],
 // so that
 //     f_0     = Int[ f(x), {x,-1,-1+2/M}]
 //     f_i     = Int[ f(x), {x,-1+2*i/M, -1+2*(i+1)/M}]
 //     f_{M-1} = Int[ f(x), {x, 1-2/M, 1}]
 // We further assume that function f(x) is very well represented by Legendre polynomials in the form
 //     f(x) = \sum_l c_l P_l(x)
 // Then we know that
 //     f_i = \sum_l c_l Int[ P_l(x), {x,-1+2*i/M, -1+2*(i+1)/M}]
 // which can be cast into the form
 //     f_i  = \sum_l Ker0(i,l) * c_l
 // with
 //     K0(i,l) = Int[ P_l(x), {x,-1+2*i/M, -1+2*(i+1)/M}] = 1/(x_{i+1}-x_i) \sum_n p_{l,n} (x_{i+1}^{n+1}-x_i^{n+1})/(n+1)
 // We can then obtain coefficients c_l by inversion of K0, i.e.,
 //     c_l = K0^{-1} f_i
 // Because Kernel is singular, we regularize it by Ridge regression. This amounts of minimizing the functional
 //     chi2 = |Ker0 * c - f|^2 + alpha * c*c
 //  where alpha is a small positive constant.
 // The minimization of the functional delivers minimum at
 //     K0^T * (f - K0 * c) = alpha * c
 // If we use singular value decomposion on K0, i.e., K0 = U * S * Vt, we can solve
 //     c = Vt^T  * S/(S^2+alpha) * U^T * f
 // This function returns the following Kernel
 //     Ker = Vt^+ * S/(S^2+alpha) * U^T
 // so that we can use it to obtain Legendre coefficients cl by:
 //     cl(l)  = \sum_i Ker(l,i) * fi(i)
 // where fi(i) is binned function, and cl(l) are Legendre coefficients of function f(x) = \sum_l cl(l) P_l(x)
 //
  Array<double,2> cPl(lmax+1,lmax+1);
  LegendreCoeff(cPl, lmax);
  //cout << "cPl = " << cPl << endl;
  int M = X.extent(0)-1;

  cout<<"X = "<< X << endl;
  
  Array<double,2> Ker0(M,lmax+1);
  Ker0 = 0;
  for (int i=0; i<M; i++){
    double xi_n = X(i);
    double xip_n = X(i+1);
    Array<double,1> r(lmax+1);
    for (int n=0; n<=lmax; n++){
      r(n) = (xip_n - xi_n)/(n+1.);
      xi_n *= X(i);
      xip_n *= X(i+1);
    }
    r *= 1/(X(i+1)-X(i));
    for (int l=0; l<=lmax; l++)
      for (int n=0; n<=l; n++)
	Ker0(i,l) += r(n)*cPl(l,n);
  }
  Array<double,2> U, Vt;
  Array<double,1> S;
  int Nl;
  SVD(U, S, Vt, Nl, Ker0);
  //cout<<" singular values = "<< S << endl;
  Nl = lmax+1;
  double alpha=1e-10;
  Array<double,2> SU(Nl,M);
  SU=0.;
  for (int l1=0; l1<Nl; l1++){
    double S_regularized = S(l1)/(S(l1)*S(l1)+alpha);
    for (int i=0; i<M; i++)
      SU(l1,i) = S_regularized*U(i,l1);
  }
  Ker.resize(Nl,M);
  Product(Ker, Vt, "T", SU, "N");
}


PYBIND11_PLUGIN(bin2leg) {
  py::module m("bin2leg", "pybind11 wrap for conversion from binned function to Legendre representation.\n\
    Contains function : \n\
         Ker = K_binned_2_Legendre(lmax,M) \n\
    which returns Kernel to obtain Legendre coefficients cl from binned data.\n"
    );
  m.def("K_binned_2_Legendre", [](int lmax, int M)->py::array_t<double>{
      py::array_t<double> _Ker_({lmax+1, M});
      py::buffer_info info = _Ker_.request();
      Array<double,2> Ker((double*)info.ptr, bl::shape(info.shape[0],info.shape[1]), bl::neverDeleteData);
      K_binned_2_Legendre(Ker, lmax, M);
      return _Ker_;
    }," Computes the Kernel which can be used to obtain Legendre coefficients cl from binned data by: cl(l)  = sum_i Ker(l,i) * fi(i)"
    );
  m.def("K_binned_2_Legendre", [](int lmax, py::array_t<double>& _x_)->py::array_t<double>{
      py::buffer_info info_x = _x_.request();
      Array<double,1> X((double*)info_x.ptr, info_x.shape[0], bl::neverDeleteData);
      py::array_t<double> _Ker_({lmax+1, X.extent(0)-1});
      py::buffer_info info = _Ker_.request();
      Array<double,2> Ker((double*)info.ptr, bl::shape(info.shape[0],info.shape[1]), bl::neverDeleteData);
      K_binned_2_Legendre(Ker, lmax, X);
      return _Ker_;
    }," Computes the Kernel which can be used to obtain Legendre coefficients cl from binned data by: cl(l)  = sum_i Ker(l,i) * fi(i)"
    );
  return m.ptr();	
}

/*
void test2()
{
  Array<double,1> cl(22);
  // exact coefficients for function f(x) = = Sin[4 Pi (x + 1)]/(4 Pi (x + 1))
  cl = 0.0609218, -0.182765, 0.257115, -0.315632, 0.272804, -0.203374, \
	0.0559767, 0.11776, -0.166279, 0.218444, -0.022258, -0.193853,	\
	0.0652448, 0.0745533, -0.0300587, -0.0177704, 0.00772425, 0.0029803, \
	-0.00134934, -0.000376414, 0.000174772, 0.0000373916;
  // Various binned approximation for the same function.
  Array<double,1> fi20(20);
  fi20 = 0.9163165691059532, 0.5014843800532618, 0.01312847274682373, \
    -0.2015580089227751, -0.1008422460079128, 0.07761384308432241,    \
    0.1097152261480756, 0.001427593288134597, -0.08304225221680145,   \
    -0.04681940256994429, 0.04111466520516524, 0.06178956523447549,   \
    0.0005130617423916136, -0.05233146708809211, -0.03049695605871010,\
    0.02796973070925076, 0.04301266821005888, 0.0002616439600343681,  \
    -0.03820691659392660, -0.02261460738523530;
  Array<double,1> fi30(30);
  fi30 = 0.9618202073597186, 0.7513053252420285, 0.4135758911370753,	\
    0.07593393180947961, -0.1487123511129193, -0.2098658849604874,	\
    -0.1340727826417583, -0.001459530781417515, 0.1006897090377903,	\
    0.1215425445309872, 0.06553327582494285, -0.02036159120161468,	\
    -0.08008164391996615, -0.08182964659295632, -0.03288119166719614,	\
    0.03011375382546626, 0.06673498393309116, 0.05750760790090368,	\
    0.01326327883388607, -0.03477056699211767, -0.05622031986031915,	\
    -0.04018839729603681, -0.0001617866472255731, 0.03655934591907338,	\
    0.04707006866199291, 0.02682204838416848, -0.008980648791021520,	\
    -0.03645071864438747, -0.03871334672492233, -0.01606822059943306;
  Array<double,1> fi40(40);
  fi40 = 0.9783255667505868, 0.8543075714613195, 0.6346401233277386, \
    0.3683286367787850, 0.1118474628619883, -0.08559051736834085,    \
    -0.1940769624637226, -0.2090390553818276, -0.1498443473912229,   \
    -0.05184014462460272, 0.04539456142873166, 0.1098331247399132,   \
    0.1253058407925831, 0.09412461150356823, 0.03374971567586224,    \
    -0.03089452909959304, -0.07660342365771803, -0.08948108077588488,	\
    -0.06861848649848551, -0.02502031864140307, 0.02341613984124027,	\
    0.05881319056909022, 0.06958901015984329, 0.05399012030910769,	\
    0.01987901065898574, -0.01885288717420251, -0.04772952943366786,	\
    -0.05693340474251636, -0.04450333729851167, -0.01649057481890853,	\
    0.01577819669340371, 0.04016126472509780, 0.04817293135225432,	\
    0.03785240506786343, 0.01408910028917133, -0.01356581236910259,	\
    -0.03466476840466702, -0.04174906478318618, -0.03293103736029928,	\
    -0.01229817741017132;
  Array<double,1> fi100(100);
  fi100 = 0.9964974499793847, 0.9756408901433539, 0.9347138302751155, \
    0.8752531165852663, 0.7994775585466454, 0.7101889146962646,	      \
    0.6106475086222315, 0.5044285116891445, 0.3952658355308907,	      \
    0.2868911297277775, 0.1828755518526649, 0.08648176173931427,      \
    0.0005330032246803935, -0.07269479195776333, -0.1315531611247776, \
    -0.1750702525429093, -0.2029672641690267, -0.2156421417697885,    \
    -0.2141221262490941, -0.1999882598830569, -0.1752762961904117,    \
    -0.1423595416427536, -0.1038199367996493, -0.06231412401328955,   \
    -0.02044133139345986, 0.01938036971407448, 0.05502348301473506,   \
    0.08474113285827414, 0.1072338331475334, 0.1216903966869950,      \
    0.1278018259843799, 0.1257484751390154, 0.1161621678936760,	      \
    0.1000662256548126, 0.07879743606849428, 0.05391482406946510,     \
    0.02710063413589031, 0.00005917204346171540, -0.02558091874917474,	\
    -0.04835574505896941, -0.06704206226610367, -0.08071630638608292,	\
    -0.08879413710647236, -0.09104903622226104, -0.08760971910308728,	\
    -0.07893730739551300, -0.06578431338946912, -0.04913844112424368,	\
    -0.03015496680608671, -0.01008198413440893, 0.009816934546724067,	\
    0.02833811087579327, 0.04440687574733115, 0.05713663250792250,	\
    0.06587477234805523, 0.07023320248344263, 0.07010220820378363,	\
    0.06564737667317283, 0.05729030438346806, 0.04567473442851030,	\
    0.03162057269794394, 0.01606887032765860, 0.00002130048177578609,	\
    -0.01552211981503375, -0.02962331498038650, -0.04146091811852575,	\
    -0.05037641886006947, -0.05590918572682543, -0.05781858452857171,	\
    -0.05609222820646819, -0.05094024379433702, -0.04277627779309799,	\
    -0.03218673327388777, -0.01989039631275123, -0.006691129119476485,	\
    0.006573344993129208, 0.01908338052414458, 0.03008692298169977,	\
    0.03894366878690134, 0.04516133626037889, 0.04842204679284850,	\
    0.04859745773388923, 0.04575199793094384, 0.04013428933029217,	\
    0.03215754926232064, 0.02237041580600039, 0.01142018544630878,	\
    0.00001086738839855276, -0.01114127983779604, -0.02135196900273984, \
    -0.03001017544008585, -0.03661404710810324, -0.04079935984682358,	\
    -0.04235894027008676, -0.04125206030453358, -0.03760343767824644,	\
    -0.03169211661605029, -0.02393111371181702, -0.01483925900521099,	\
    -0.005007109914851769;

  int lmax = cl.extent(0)-1;
  const int Ncase=4;
  Array<double,1> fs[Ncase] = {fi20,fi30,fi40,fi100};
  string which[Ncase] = {"20", "30", "40", "100"};
  for (int icase=0; icase<Ncase; icase++){
    int M = fs[icase].size();
    Array<double,2> Ker;
    K_binned_2_Legendre(Ker, lmax, M);
    Array<double,1> Cl(lmax+1);
    MProduct(Cl, Ker, fs[icase]);
    cout << "# l    Cl_apprx     Cl_exact with "<<which[icase]<<" bins"<<endl;
    for (int l=0; l<lmax+1; l++)
      cout << setw(2)<< l << "  "<< setw(12) << Cl(l) << " "<< setw(12) << cl(l) << endl;
  }
}

void test1()
{
  Array<double,1> cl(20);
  // exact coefficients for function f(x) = exp(-3*x)
  cl = 3.339291642469967, -6.728370353307799, 5.482507623503506,  \
      -2.907013036210017, 1.147474613676259, -0.3607564258027895, \
      0.09418548572028671, -0.02101315203873403, 0.004091106953189763,\
     -0.0007063152121946091, 0.0001095138685780318,		      \
    -0.00001540682583909036, 1.983437743332414*1e-6, \
    -2.353341211143548*1e-7, 2.589127816016967*1e-8, \
    -2.655227698431960*1e-9, 2.549842581311661*1e-10, -2.302137917247934*1e-11,\
    1.961097807698588*1e-12,-1.581224349667697*1e-13;
  // Various binned approximation for function f(x) = exp(-3*x)
  Array<double,1> fi20(20);
  fi20 = 17.35268399438278, 12.85518448077077, 9.523354893579839,  \
       7.055074827182347, 5.226527980249604, 3.871907158671724,	   \
       2.868379371931993, 2.124947702554802, 1.574199976048353,	   \
       1.166196025253344, 0.8639392643942738, 0.6400219486256381,  \
       0.4741399211780911, 0.3512514927613234, 0.2602135058792409, \
       0.1927709064228110, 0.1428081998953488, 0.1057949165452314, \
       0.07837480183220913, 0.05806148123961941;
  Array<double,1> fi30(30);
  fi30 = 18.20445076045309, 14.90454368047680, 12.20280827180044,\
       9.990814406037404, 8.179787002517353, 6.697043172588521,	 \
       5.483075200089156, 4.489162287752201, 3.675415220540635,	 \
       3.009175471387511, 2.463704499832888, 2.017110640509793,	 \
       1.651470513746193, 1.352109697405502, 1.107013790800849,	 \
       0.9063462346100907, 0.7420535352117128, 0.6075420497080643,\
       0.4974133598840242, 0.4072476147288963, 0.3334261462962011,\
       0.2729862398529781, 0.2235022297347553, 0.1829881488653444,\
       0.1498180249248692, 0.1226606243713940, 0.1004260253646069,\
       0.08222187537539311, 0.06731757794557958, 0.05511497128677011;
  Array<double,1> fi40(40);
  fi40 = 18.65170055080019, 16.05366743796537, 13.81751961473201, \
    11.89284934680954, 10.23627029522051, 8.810439491939171,	  \
    7.583215546522378, 6.526934107842315, 5.617784248220649,	  \
    4.835271712278559, 4.161756930940603, 3.582057386402846,	  \
    3.083105364489225, 2.653653379374761, 2.284020630295167,	  \
    1.965874774814438, 1.692044099335601, 1.456355852761105,	  \
    1.253497098984800, 1.078894951521887, 0.9286134904996146,	  \
    0.7992650382889329, 0.6879337937329638, 0.5921101035183124,   \
    0.5096338890200782, 0.4386459533361040, 0.3775460708629584,   \
    0.3249569146596884, 0.2796930084420706, 0.2407340033164112,   \
    0.2072016768511714, 0.1783401359944505, 0.1534987775671531,   \
    0.1321176222235444, 0.1137146912741172, 0.09787514181634556,  \
    0.08424191525506234, 0.07250768840935591, 0.06240794576607535,\
    0.05371501671316347;
  Array<double,1> fi100(100);
  fi100= 19.49484351554380, 18.35955221071402, 17.29037512453875, \
    16.28346206465793, 15.33518705645939, 14.44213528565368,	  \
    13.60109080125426, 12.80902493468023, 12.06308539327814,	  \
    11.36058598898755, 10.69899696516261, 10.07593588671566,	  \
    9.489159060777569, 8.936553456979935, 8.416129098263414,	  \
    7.926011894810867, 7.464436895299764, 7.029741931171040,	  \
    6.620361631026930, 6.234821783603133, 5.871734029015918,	  \
    5.529790859166937, 5.207760909301793, 4.904484523766886,	  \
    4.618869579996487, 4.349887555691867, 4.096569825030078,	  \
    3.858004170564759, 3.633331498258007, 3.421742743813911,	  \
    3.222475959173196, 3.034813568677199, 2.858079785020432,	  \
    2.691638175686337, 2.534889371102801, 2.387268906264299,	  \
    2.248245188048177, 2.117317580905223, 1.994014604030937,	  \
    1.877892233525376, 1.768532303427509, 1.665540999866085,	  \
    1.568547442904326, 1.477202350971559, 1.391176783072286,	  \
    1.310160954243307, 1.233863119993242, 1.162008525707242,	  \
    1.094338417233601, 1.030609109089327, 0.9705911069291882,	  \
    0.9140682811181866, 0.8608370884314249, 0.8107058390786435,	  \
    0.7634940064139257, 0.7190315768447801, 0.6771584375995713,	  \
    0.6377238001485988, 0.6005856572025198, 0.5656102713327205,	  \
    0.5326716933721199, 0.5016513088621265, 0.4724374109124684,	  \
    0.4449247979357309, 0.4190143948080097, 0.3946128960914515,   \
    0.3716324300338954, 0.3499902421356525, 0.3296083971439210,   \
    0.3104134984016966, 0.2923364235405287, 0.2753120755653334,   \
    0.2592791484348976, 0.2441799062939126, 0.2299599755615321,   \
    0.2165681491277515, 0.2039562019525009, 0.1920787174034119,   \
    0.1808929237068849, 0.1703585399235056, 0.1604376308931538,   \
    0.1510944706274529, 0.1422954136576221, 0.1340087738744482,   \
    0.1262047104240668, 0.1188551202486564, 0.1119335368850757,   \
    0.1054150351570086, 0.09927614141740741, 0.09349474901800861, \
    0.08805003870152127, 0.08292240362981323, 0.07809337877811586,\
    0.07354557444099035, 0.06926261361060492, 0.06522907300181738,\
    0.06143042751168946, 0.05785299791342722, 0.05448390159638930,\
    0.05131100617477367;
  
  int lmax = cl.extent(0)-1;
  const int Ncase=4;
  Array<double,1> fs[Ncase] = {fi20,fi30,fi40,fi100};
  string which[Ncase] = {"20", "30", "40", "100"};
  for (int icase=0; icase<Ncase; icase++){
    int M = fs[icase].size();
    Array<double,2> Ker;
    K_binned_2_Legendre(Ker, lmax, M);
    Array<double,1> Cl(lmax+1);
    MProduct(Cl, Ker, fs[icase]);
    cout << "# l    Cl_apprx     Cl_exact with "<<which[icase]<<" bins"<<endl;
    for (int l=0; l<lmax+1; l++)
      cout << setw(2)<< l << "  "<< setw(12) << Cl(l) << " "<< setw(12) << cl(l) << endl;
  }
}
*/
